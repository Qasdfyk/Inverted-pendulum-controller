\section{Środowisko symulacyjne i implementacja}

W~celu przeprowadzenia badań i~weryfikacji działania algorytmów sterowania,
przygotowano zestaw skryptów symulacyjnych zrealizowanych w~języku
Python 3. Wybór tego języka podyktowany był jego powszechnością
w~zastosowaniach naukowych, dostępnością bibliotek do~obliczeń numerycznych
i~optymalizacji, a~także łatwością prototypowania złożonych struktur sterowania.
Ogólną architekturę środowiska przedstawiono na~Rys.~\ref{fig:diagram_env}.

\begin{figure}[H]
    \centering
    \begin{tikzpicture}[auto, node distance=1.4cm, >=Stealth,
        module/.style={draw, fill=blue!10, rectangle, minimum height=2.2em, 
                       minimum width=6.5em, rounded corners=3pt, align=center, font=\small}]
        
        % Górny rząd
        \node [module, fill=orange!15] (controller) {Regulator};
        \node [module, left=2cm of controller, fill=yellow!20] (model) {Model $f(x,u)$};
        \node [module, left=2cm of model, fill=green!15] (params) {Parametry};
        
        % Środkowy rząd
        \node [module, below=1.3cm of controller, fill=blue!15] (integrator) {Integrator RK4};
        \node [module, below=1.3cm of model, fill=red!10] (disturbance) {Zakłócenia $F_w$};
        
        % Dolny rząd
        \node [module, below=1.3cm of integrator, fill=purple!10] (logger) {Logger};
        \node [module, left=2cm of logger, fill=gray!15] (viz) {Wizualizacja};
        
        % Połączenia główne (góra)
        \draw [arrow] (params) -- (model);
        \draw [arrow] (model) -- (controller);
        
        % Regulator -> Integrator
        \draw [arrow] (controller) -- node[right, font=\scriptsize] {$u$} (integrator);
        
        % Zakłócenia -> Model
        \draw [arrow, dashed] (disturbance) -- (model);
        
        % Integrator -> Logger
        \draw [arrow] (integrator) -- node[right, font=\scriptsize] {$x(t)$} (logger);
        
        % Logger -> Wizualizacja  
        \draw [arrow] (logger) -- (viz);
        
        % Integrator -> Model (stan)
        \draw [arrow] (integrator.west) -- ++(-0.5,0) |- node[pos=0.25, left, font=\scriptsize] {$x$} (model.south);
        
        % Sprzężenie zwrotne do regulatora (po prawej stronie - ciągła linia)
        \draw [arrow] (integrator.east) -- ++(0.6,0) |- node[pos=0.25, right, font=\scriptsize] {$x(t)$} (controller.east);
        
    \end{tikzpicture}
    \caption{Architektura środowiska symulacyjnego.}
    \label{fig:diagram_env}
\end{figure}

\subsection{Narzędzia programistyczne}

W~projekcie wykorzystano następujące biblioteki i narzędzia:
\begin{itemize}
    \item \textbf{NumPy}~\cite{Harris2020} -- podstawowa biblioteka do~obliczeń macierzowych
    i~operacji na~wielowymiarowych tablicach danych, wykorzystywana
    do~implementacji równań stanu oraz przechowywania przebiegów symulacji.
    \item \textbf{SciPy}~\cite{Virtanen2020} -- pakiet naukowy dostarczający zaawansowanych
    algorytmów numerycznych. W~pracy użyto modułów:
    \begin{itemize}
        \item \texttt{scipy.linalg} -- do~rozwiązywania algebraicznego równania
        Riccatiego (ARE) w algorytmie LQR.
        \item \texttt{scipy.optimize} -- zawierającego solwer \texttt{minimize}
        (metoda SLSQP), wykorzystywany do~rozwiązywania zadań optymalizacji
        nieliniowej z~ograniczeniami w~regulatorze MPC.
    \end{itemize}
    \item \textbf{Matplotlib} -- biblioteka służąca do~wizualizacji wyników
    w postaci wykresów przebiegów czasowych oraz do generowania animacji ruchu
    wahadła.
\end{itemize}

\subsection{Konfiguracja symulacji}

Symulator opiera~się na~numerycznym całkowaniu wyprowadzonych wcześniej
nieliniowych równań dynamiki. Zaimplementowano procedurę całkowania metodą
Rungego-Kutty czwartego rzędu (RK4)~\cite{Fortuna2015}. Wybór tej metody podyktowany 
był kilkoma czynnikami: w~odróżnieniu od~prostszej metody Eulera, RK4 
charakteryzuje się błędem lokalnym rzędu $\mathcal{O}(\Delta t^5)$, 
co zapewnia wysoką dokładność przy umiarkowanym koszcie obliczeniowym. 
Jednocześnie, w~przeciwieństwie do~metod adaptacyjnych (np. \texttt{ode45}), 
stały krok czasowy gwarantuje deterministyczne taktowanie pętli sterowania, 
co jest istotne przy porównywaniu regulatorów.
Przyjęto stały krok symulacji oraz sterowania wynoszący
\(\Delta t = 0{,}1\,\text{s}\).

\begin{table}[H]
	\centering
	\caption{Parametry fizyczne modelu przyjęte w~symulacji}
	\label{tab:parametry_modelu}
	\renewcommand{\arraystretch}{1.2}
	\begin{tabular}{|l|c|c|c|}
		\hline
		\textbf{Parametr} & \textbf{Symbol} & \textbf{Wartość} & \textbf{Jednostka} \\ \hline
		Masa wózka & $M$ & $2{,}40$ & $\text{kg}$ \\ \hline
		Masa wahadła & $m$ & $0{,}23$ & $\text{kg}$ \\ \hline
		Długość wahadła & $l$ & $0{,}36$ & $\text{m}$ \\ \hline
		Przyspieszenie ziemskie & $g$ & $9{,}81$ & $\text{m/s}^2$ \\ \hline
        Ograniczenie sterowania & $F_\mathrm{max}$ & $100{,}00$ & $\text{N}$ \\ \hline
	\end{tabular}
\end{table}

Symulacje przeprowadzane~są dla zadania stabilizacji układu w~pionie (tzw. punkt
pracy), startując z niezerowych warunków początkowych lub wymuszając zmianę
pozycji wózka.

\textbf{Warunki początkowe:}
\[
\mathbf{x}_0 = [\theta, \dot{\theta}, x, \dot{x}]^T = [0{,}05, 0, 0, 0]^T
\]
Oznacza to niewielkie (ok. $2{,}86^\circ$) początkowe wychylenie wahadła, które
regulator musi zniwelować.

\textbf{Wartości zadane:}
Celem układu jest osiągnięcie stanu
$\mathbf{x}_\mathrm{ref} = [0, 0, x_\mathrm{ref}, 0]^T$, gdzie
$x_\mathrm{ref}$ (np. $0{,}10$ m) jest zadaną nową pozycją wózka, przy
jednoczesnym utrzymaniu pionowej pozycji wahadła ($\theta = 0$).

\subsection{Modelowanie zakłóceń}

Aby zweryfikować odporność układów sterowania, zaimplementowano generator
zakłóceń zewnętrznych działających na~wahadło. Generator ten działa
w~sposób dyskretny, realizując w~każdym kroku symulacji $k$ następujące
operacje:

\textbf{1. Dyskretne próbkowanie szumu:}
\begin{equation}
    w_k \sim \mathcal{N}\!\left(0,\;\sigma^2\right),
\end{equation}
gdzie $\sigma$ jest odchyleniem standardowym siły zakłócającej wyrażonym w~niutonach.
W~przeprowadzonych eksperymentach przyjęto $\sigma = 2{,}2$~N, co oznacza,
że wartość skuteczna (RMS) siły zakłócającej wynosi około $2{,}2$~N, 
a~chwilowe wartości szczytowe mogą osiągać $\pm 6{,}6$~N (przedział $3\sigma$).
Parametr ten dobrano empirycznie tak, aby zakłócenia stanowiły znaczące obciążenie 
dla układu sterowania (porównywalne z~kilkoma procentami maksymalnej siły aktuatora 
$F_{\max}=100$~N), lecz nie przekraczały możliwości kompensacyjnych badanych regulatorów.

\textbf{2. Wygładzanie (ruchoma średnia):}
\begin{equation}
    F_{\mathrm{w},k}=\frac{1}{N_{\mathrm{s}}}\sum_{i=0}^{N_{\mathrm{s}}-1} w_{k-i},
\end{equation}
gdzie $F_{\mathrm{w},k}$ to wypadkowa siła zakłócająca w~chwili $k$, a~$N_{\mathrm{s}}$ to długość okna
uśredniającego (przyjęto $N_{\mathrm{s}}=10$). Takie podejście pozwala na~uzyskanie
ciągłego, wolnozmiennego sygnału lepiej odwzorowującego rzeczywiste zakłócenia zewnętrzne.
Przykładowy przebieg wygenerowanego sygnału przedstawiono na~Rys.
\ref{fig:wind_signal}.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.95\textwidth]{img/wind_signal.png}
    \caption{Przykładowa realizacja stochastycznego procesu zakłócenia zewnętrznego
    działającego na wahadło w czasie symulacji.}
    \label{fig:wind_signal}
\end{figure}

\subsection{Wizualizacja i animacja}

Oprócz standardowych wykresów zmiennych stanu i sterowania, środowisko wyposażono
w moduł wizualizacji dynamicznej (Rys. \ref{fig:animacja_screenshot}).
Implementacja animacji oparta jest na bibliotece \texttt{Matplotlib} i klasie
\texttt{FuncAnimation}, która pozwala na cykliczne odświeżanie obiektów
graficznych zgodnie z taktowaniem symulacji.

Graficzna reprezentacja obiektu (robot) zbudowana jest z~prostych prymitywów
geometrycznych:
\begin{itemize}
    \item \textbf{Wózek}: obiekt typu \texttt{Rectangle}, którego pozycja
    pozioma aktualizowana jest w każdej klatce na podstawie zmiennej stanu
    $x(t)$.
    \item \textbf{Koła}: obiekty \texttt{Circle}, poruszające się wraz z
    wózkiem.
    \item \textbf{Wahadło}: obiekt liniowy, którego współrzędne końcowe
    wyznaczane są na podstawie kąta $\theta(t)$.
\end{itemize}

Kluczowym elementem implementacji jest funkcja aktualizująca \texttt{update},
wywoływana dla każdego kroku czasowego. Odpowiada ona za~przeliczenie
współrzędnych kinematycznych oraz przesunięcie okna widoku kamery tak, aby wózek
znajdował się zawsze w~centrum, co pozwala na~obserwację ruchu na~długim
dystansie. Dodatkowo rysowany jest ślad przebytej 
drogi przez oś wózka, co ułatwia wizualną ocenę stabilności pozycji.

Wykorzystanie animacji pozwala na szybką, intuicyjną weryfikację poprawności
modelu fizycznego oraz ocenę jakości regulacji w sposób trudny do uchwycenia na
statycznych wykresach (np. nienaturalne drgania czy gwałtowne, nieciągłe 
zmiany sygnału sterującego).

\begin{figure}[H]
    \centering
    \includegraphics[width=0.95\textwidth]{img/animation.png}
    \caption{Zrzut ekranu z animacji realizowanej w środowisku Python
    (biblioteka Matplotlib). Widoczny wózek, wahadło oraz zakres ruchu.}
    \label{fig:animacja_screenshot}
\end{figure}
