\section{Środowisko symulacyjne i implementacja}

W~celu przeprowadzenia badań i~weryfikacji działania algorytmów sterowania,
przygotowano zestaw skryptów symulacyjnych zrealizowanych w~języku
Python 3. Wybór tego języka podyktowany był jego powszechnością
w~zastosowaniach naukowych, dostępnością bibliotek do~obliczeń numerycznych
i~optymalizacji, a~także łatwością prototypowania złożonych struktur sterowania.
Ogólną architekturę środowiska przedstawiono na~Rys.~\ref{fig:control_loop} i na~Rys.~\ref{fig:app_architecture}.

% --- DIAGRAM 1: PĘTLA SYMULACYJNA (RDZEŃ MATEMATYCZNY) ---
\begin{figure}[H]
    \centering
    \begin{tikzpicture}[auto, node distance=2cm, >=stealth,
        block/.style={draw, rectangle, minimum height=2.5em, minimum width=4em, rounded corners=3pt, align=center, font=\small, thick},
        line/.style={draw, thick, ->},
        sum/.style={draw, circle, inner sep=0pt, minimum size=6mm, thick}]

        % Węzły (Nodes)
        \node [block, fill=orange!15] (controller) {Regulator};
        \node [sum, right=1.5cm of controller] (sum) {+};
        \node [block, right=1.0cm of sum, fill=yellow!20] (model) {Model nieliniowy\\$f(x, u, F_w)$};
        \node [block, right=1.5cm of model, fill=blue!15] (integrator) {Integrator\\RK4};
        
        % Zakłócenia (powyżej sumatora/modelu)
        \node [block, above=1.2cm of sum, fill=red!10] (dist) {Generator\\zakłóceń $F_w$};

        % Połączenia (Paths)
        % 1. Regulator -> Sumator (u)
        \draw [line] (controller) -- node[above] {$u$} (sum);
        
        % 2. Zakłócenia -> Sumator
        \draw [line] (dist) -- node[right] {$F_w$} (sum);
        
        % 3. Sumator -> Model
        \draw [line] (sum) -- (model);
        
        % 4. Model -> Integrator (dx)
        \draw [line] (model) -- node[above] {$\dot{x}$} (integrator);
        
        % 5. Sprzężenie zwrotne (x) - z dołu
        % Wychodzi z integratora w prawo, w dół, w lewo pod spodem, do regulatora i modelu
        \draw [line] (integrator.east) -- ++(0.5,0) |- ++(0,-1.5) -| node[pos=0.35, above] {$x$} (controller.south);
        
        % Dodatkowa strzałka stanu wchodząca do modelu (dla kompletności matematycznej)
        %\draw [line] ($(controller.south) + (2.5,-1.5)$) -- ++(0, 0.6) -| (model.south);
        \draw [line] (integrator.east) -- ++(0.5,0) |- ++(0,-1.5) -| node[pos=0.25, above] {$x$} (model.south);

    \end{tikzpicture}
    \caption{Schemat blokowy pętli symulacyjnej (rdzeń obliczeniowy).}
    \label{fig:control_loop}
\end{figure}

% --- DIAGRAM 2: ARCHITEKTURA APLIKACJI (PIPELINE DANYCH) ---
\begin{figure}[H]
    \centering
    \begin{tikzpicture}[auto, node distance=1.5cm, >=stealth,
        module/.style={draw, rectangle, minimum height=2.5em, minimum width=7em, rounded corners=3pt, align=center, font=\small, fill=white},
        container/.style={draw, dashed, inner sep=0.5cm, rounded corners=5pt, fill=gray!5, label={above:\textit{#1}}}]

        % Węzły
        \node [module, fill=green!15] (config) {Parametry};
        \node [module, right=1.5cm of config, fill=blue!10, text width=2.5cm] (sim) {Pętla główna};
        \node [module, right=1.5cm of sim, fill=purple!15] (logger) {Zapis historii};
        
        % Rozwidlenie na końcu
        \node [module, above right=0.5cm and 1.0cm of logger, fill=gray!20] (viz) {Animacja};
        \node [module, below right=0.5cm and 1.0cm of logger, fill=gray!20] (analysis) {Analiza wyników};

        % Połączenia
        \draw [line, thick, ->] (config) -- node[above, font=\scriptsize] {Inicjalizacja} (sim);
        \draw [line, thick, ->] (sim) -- node[above, font=\scriptsize] {$x, u$} (logger);
        
        % Wyjścia z loggera
        \draw [line, thick, ->] (logger.east) -- ++(0.5,0) |- (viz.west);
        \draw [line, thick, ->] (logger.east) -- ++(0.5,0) |- (analysis.west);

    \end{tikzpicture}
    \caption{Architektura przepływu danych w zrealizowanej aplikacji.}
    \label{fig:app_architecture}
\end{figure}

\subsection{Narzędzia programistyczne}

W~projekcie wykorzystano następujące biblioteki i narzędzia:
\begin{itemize}
    \item \textbf{NumPy}~\cite{Harris2020} -- podstawowa biblioteka do~obliczeń macierzowych
    i~operacji na~wielowymiarowych tablicach danych, wykorzystywana
    do~implementacji równań stanu oraz przechowywania przebiegów symulacji.
    \item \textbf{SciPy}~\cite{Virtanen2020} -- pakiet naukowy dostarczający zaawansowanych
    algorytmów numerycznych. W~pracy użyto modułów:
    \begin{itemize}
        \item \texttt{scipy.linalg} -- do~rozwiązywania algebraicznego równania
        Riccatiego (ARE) w algorytmie LQR.
        \item \texttt{scipy.optimize} -- zawierającego solwer \texttt{minimize}
        (metoda SLSQP), wykorzystywany do~rozwiązywania zadań optymalizacji
        nieliniowej z~ograniczeniami w~regulatorze MPC.
    \end{itemize}
    \item \textbf{Matplotlib} -- biblioteka służąca do~wizualizacji wyników
    w postaci wykresów przebiegów czasowych oraz do generowania animacji ruchu
    wahadła.
\end{itemize}

\subsection{Konfiguracja symulacji}

Symulator opiera~się na~numerycznym całkowaniu wyprowadzonych wcześniej
nieliniowych równań dynamiki. Wybrano procedurę całkowania metodą
Runge-Kutta czwartego rzędu (RK4). Wybór tej metody podyktowany 
był kilkoma czynnikami: w~odróżnieniu od~prostszej metody Eulera, RK4 
charakteryzuje się błędem lokalnym rzędu $\mathcal{O}(\Delta t^5)$, 
co zapewnia wysoką dokładność przy umiarkowanym koszcie obliczeniowym. 
Jednocześnie, w~przeciwieństwie do~metod adaptacyjnych (np. \texttt{ode45}), 
stały krok czasowy gwarantuje deterministyczne taktowanie pętli sterowania, 
co jest istotne przy porównywaniu regulatorów. Symulacja prowadzona jest ze stałym krokiem czasowym $T = 0{,}1$~s.

\begin{table}[H]
	\centering
	\caption{Parametry fizyczne modelu przyjęte w~symulacji}
	\label{tab:parametry_modelu}
	\renewcommand{\arraystretch}{1.2}
	\begin{tabular}{|l|c|c|c|}
		\hline
		\textbf{Parametr} & \textbf{Symbol} & \textbf{Wartość} & \textbf{Jednostka} \\ \hline
		Masa wózka & $M$ & $2{,}40$ & $\mathrm{kg}$ \\ \hline
		Masa wahadła & $m$ & $0{,}23$ & $\mathrm{kg}$ \\ \hline
		Długość wahadła & $l$ & $0{,}36$ & $\mathrm{m}$ \\ \hline
		Przyspieszenie ziemskie & $g$ & $9{,}81$ & $\mathrm{m/s^2}$ \\ \hline
        Ograniczenie sterowania & $F_\mathrm{max}$ & $100{,}00$ & $\mathrm{N}$ \\ \hline
	\end{tabular}
\end{table}

Symulacje przeprowadzane~są dla zadania stabilizacji układu w~pionie (tzw. punkt
pracy), startując z niezerowych warunków początkowych lub wymuszając zmianę
pozycji wózka.

\textbf{Warunki początkowe:}
\[
x_0 = [\theta, \dot{\theta}, x, \dot{x}]^T = [\theta_0, 0, 0, 0]^T
\]
gdzie $\mathrm{\theta_0}$ to $0,05$[rad].
Oznacza to niewielkie (ok. $2{,}86^\circ$) początkowe wychylenie wahadła, które
regulator musi zniwelować.

\textbf{Wartości zadane:}
Celem układu jest osiągnięcie stanu
$x_\mathrm{ref} = [0, 0, x_\mathrm{ref}, 0]^T$, gdzie
$x_\mathrm{ref}$ ($0{,}10$ m) jest zadaną nową pozycją wózka, przy
jednoczesnym utrzymaniu pionowej pozycji wahadła ($\theta = 0$).

\subsection{Modelowanie zakłóceń}

Aby zweryfikować odporność układów sterowania, zaimplementowano generator
zakłóceń zewnętrznych działających na~wahadło. Generator ten działa
w~sposób dyskretny, realizując w~każdym kroku symulacji $k$ następujące
operacje:

\textbf{1. Próbkowanie szumu:}
\begin{equation}
    w(k) \sim \mathcal{N}\!\left(0,\;\sigma^2\right),
\end{equation}
gdzie $\sigma$ jest odchyleniem standardowym siły zakłócającej wyrażonym w~niutonach.
W~przeprowadzonych eksperymentach przyjęto $\sigma = 2{,}2$~N, co oznacza,
że wartość skuteczna (RMS) siły zakłócającej wynosi około $2{,}2$~N, 
a~chwilowe wartości szczytowe mogą osiągać $\pm 6{,}6$~N (przedział $3\sigma$).
Parametr ten dobrano empirycznie tak, aby zakłócenia stanowiły znaczące obciążenie 
dla układu sterowania (porównywalne z~kilkoma procentami maksymalnej siły urządzenia wykonawczego 
$F_{\max}=100$~N), lecz nie przekraczały możliwości kompensacyjnych badanych regulatorów.

\textbf{2. Wygładzanie (ruchoma średnia):}
\begin{equation}
    F_{\mathrm{w}}(k)=\frac{1}{N_{\mathrm{s}}}\sum_{i=0}^{N_{\mathrm{s}}-1} w_{k-i},
\end{equation}
gdzie $F_{\mathrm{w}}(k)$ to wypadkowa siła zakłócająca w danej chwili, a~$N_{\mathrm{s}}$ to długość okna
uśredniającego (przyjęto $N_{\mathrm{s}}=10$). Takie podejście pozwala na~uzyskanie
ciągłego, wolnozmiennego sygnału lepiej odwzorowującego rzeczywiste zakłócenia zewnętrzne.
Przykładowy przebieg wygenerowanego sygnału przedstawiono na~Rys.
\ref{fig:wind_signal}.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.95\textwidth]{img/wind_signal.png}
    \caption{Przykładowa realizacja stochastycznego procesu zakłócenia zewnętrznego
    działającego na wahadło w czasie symulacji.}
    \label{fig:wind_signal}
\end{figure}

\subsection{Wizualizacja i animacja}

Oprócz standardowych wykresów zmiennych stanu i sterowania, środowisko wyposażono
w moduł wizualizacji dynamicznej (Rys. \ref{fig:animacja_screenshot}).
Implementacja animacji oparta jest na bibliotece \texttt{Matplotlib} i klasie
\texttt{FuncAnimation}, która pozwala na cykliczne odświeżanie obiektów
graficznych zgodnie z taktowaniem symulacji.

Graficzna reprezentacja obiektu (robot) zbudowana jest z~prostych prymitywów
geometrycznych:
\begin{itemize}
    \item \textbf{Wózek}: obiekt typu \texttt{Rectangle}, którego pozycja
    pozioma aktualizowana jest w każdej klatce na podstawie zmiennej stanu
    $x(t)$.
    \item \textbf{Koła}: obiekty \texttt{Circle}, poruszające się wraz z
    wózkiem.
    \item \textbf{Wahadło}: obiekt liniowy, którego współrzędne końcowe
    wyznaczane są na podstawie kąta $\theta(t)$.
\end{itemize}

Kluczowym elementem implementacji jest funkcja aktualizująca \texttt{update},
wywoływana dla każdego kroku czasowego. Odpowiada ona za~przeliczenie
współrzędnych kinematycznych oraz przesunięcie okna widoku kamery tak, aby wózek
znajdował się zawsze w~centrum, co pozwala na~obserwację ruchu na~długim
dystansie. Dodatkowo rysowany jest ślad przebytej 
drogi przez oś wózka, co ułatwia wizualną ocenę stabilności pozycji.

Wykorzystanie animacji pozwala na szybką, intuicyjną weryfikację poprawności
modelu fizycznego oraz ocenę jakości regulacji w sposób trudny do uchwycenia na
statycznych wykresach (np. nienaturalne drgania czy gwałtowne, nieciągłe 
zmiany sygnału sterującego).

\begin{figure}[H]
    \centering
    \includegraphics[width=0.95\textwidth]{img/animation.png}
    \caption{Zrzut ekranu z animacji realizowanej w środowisku Python
    (biblioteka Matplotlib). Widoczny wózek, wahadło oraz zakres ruchu.}
    \label{fig:animacja_screenshot}
\end{figure}
