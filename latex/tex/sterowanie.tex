\section{Algorytmy sterowania}

W~niniejszym rozdziale przedstawiono szczegółowy opis algorytmów sterowania
zaimplementowanych i~przeanalizowanych w~ramach pracy. Kod regulatorów został
zrealizowany w~języku Python w~postaci klas dziedziczących wspólną strukturę,
co zapewnia modularność i~łatwą wymienność w~pętli symulacyjnej. Każdy
regulator wyznacza sygnał sterujący $\mathrm{u(t)}$ (siłę przyłożoną do wózka)
na~podstawie aktualnego wektora stanu
$x(t) = [\theta, \dot{\theta}, x, \dot{x}]^T$ oraz wartości zadanych
$x_{\mathrm{ref}}$.

W~literaturze problem sterowania wahadłem odwróconym jest szeroko omawiany
jako klasyczny problem testowy dla metod sterowania liniowego i~nieliniowego
\cite{Prasad2014, Nguyen2024}. Poniżej opisano teoretyczne podstawy oraz szczegóły
implementacyjne zbadanych struktur sterowania.

\subsection{Równoległy regulator PID}

Pierwszym zaimplementowanym układem jest regulator o~strukturze równoległej,
wykorzystujący klasyczne sprzężenie zwrotne typu PID~\cite{Prasad2014}. 
W~literaturze podejście to jest często
stosowane jako punkt odniesienia dla bardziej zaawansowanych metod
\cite{Prasad2014}.

W~klasie \texttt{PDPDController} zastosowano strukturę równoległą, w~której
całkowity sygnał sterujący jest sumą reakcji na~błąd kąta oraz błąd pozycji.
Jest to podejście intuicyjne, dekomponujące problem na~dwa podzadania:
stabilizację wahadła w~pozycji pionowej oraz doprowadzenie wózka do~zadanej
pozycji. Schemat blokowy regulatora przedstawiono na~Rys.~\ref{fig:diagram_pdpd}.

\begin{figure}[H]
    \centering
    \begin{tikzpicture}[auto, node distance=1.5cm, >=Stealth]
        % Wejścia (po lewej)
        \node [input] (in_theta) {};
        \node [below=1.2cm of in_theta, input] (in_x) {};
        
        % Sumy błędów
        \node [sum, right=0.8cm of in_theta] (sum_theta) {\tiny $+$};
        \node [sum, right=0.8cm of in_x] (sum_x) {\tiny $+$};
        
        % Regulatory PD
        \node [block, right=0.8cm of sum_theta] (pd_theta) {$\mathrm{PID}_\theta$};
        \node [block, right=0.8cm of sum_x] (pd_x) {$\mathrm{PID}_x$};
        
        % Suma sterowania (między nimi)
        \node [sum, right=1.8cm of pd_theta, yshift=-0.6cm] (sum_u) {\tiny $+$};
        
        % Saturacja i obiekt
        \node [bigblock, right=1.5cm of sum_u] (plant) {Wahadło};
        
        % Wyjście
        \node [output, right=1.2cm of plant] (out) {};
        
        % --- Połączenia ---
        % Wejścia do sum
        \draw [arrow] (in_theta) -- node[above, font=\scriptsize] {$\theta_{\mathrm{ref}}$} (sum_theta);
        \draw [arrow] (in_x) -- node[above, font=\scriptsize] {$x_{\mathrm{ref}}$} (sum_x);
        
        % Sumy do PD
        \draw [arrow] (sum_theta) -- (pd_theta);
        \draw [arrow] (sum_x) -- (pd_x);
        
        % PD do sumy sterowania (rozdzielone wejścia: góra i dół)
        \draw [arrow] (pd_theta.east) -| node[above, font=\scriptsize] {$\mathrm{u_p}$} (sum_u.north);
        \draw [arrow] (pd_x.east) -| node[below, font=\scriptsize] {$\mathrm{u_c}$} (sum_u.south);
        
        % Suma -> sat -> plant -> wyjście
        \draw [arrow] (sum_u) -- node[above, font=\scriptsize] {$\mathrm{u}$} (plant);
        \draw [arrow] (plant) -- node[above, font=\scriptsize] {$\mathrm{\theta,x}$} (out);
        
        % Sprzężenie zwrotne (na dole) - ciągła linia
        \draw [arrow] ($(plant.east) + (0.3,0)$) -- ++(0,+1.8) -| (sum_theta.north);
        \draw [arrow] ($(plant.east) + (0.3,0)$) -- ++(0,-1.8) -| (sum_x.south);
        
        % Znak minus na sumach
        \node [above=3pt of sum_theta.north, font=\tiny] {$-$};
        \node [below=3pt of sum_x.south, font=\tiny] {$-$};
    \end{tikzpicture}
    \caption{Schemat blokowy regulatora PID o~strukturze równoległej.}
    \label{fig:diagram_pdpd}
\end{figure}
Prawo sterowania wyraża się wzorem:
\begin{equation}
    \mathrm{u(t)} = u_{\theta}(t) + u_{x}(t),
\end{equation}
Definiując uchyby regulacji jako $e_{\theta}(t) = \theta_{\mathrm{ref}} - \theta(t)$ 
oraz $e_x(t) = x_{\mathrm{ref}} - x(t)$, prawo sterowania dla poszczególnych pętli 
można zapisać w~ogólnej postaci regulatora PID:
\begin{align}
    u_{\theta}(t) &= K_{p,\theta} e_{\theta}(t) + K_{i,\theta} \int_0^t e_{\theta}(\tau)\,d\tau + K_{d,\theta} \frac{d e_{\theta}(t)}{dt}, \label{eq:pd_theta} \\
    u_{x}(t) &= K_{p,x} e_x(t) + K_{i,x} \int_0^t e_x(\tau)\,d\tau + K_{d,x} \frac{d e_x(t)}{dt}. \label{eq:pd_x}
\end{align}
W~powyższych równaniach przyjęto upraszczające założenie, że docelowe
prędkości ($\dot{\theta}_{\mathrm{ref}}, \dot{x}_{\mathrm{ref}}$) wynoszą zero.

\subsubsection{Proces doboru nastaw oraz analiza PID}
Dobór nastaw dla regulatora PID został zrealizowany wieloetapowo, przechodząc
od metod heurystycznych do pełnej optymalizacji numerycznej.
Wstępny dobór nastaw przeprowadzono metodą eksperymentalną, 
jednak nie pozwoliła ona na uzyskanie zadowalających wskaźników jakości
, gdyż obiekt wahadła na wózku wymaga bardzo precyzyjnych nastaw, 
a dobór parametrów metodą prób i błędów jest czasochłonny i nie gwarantuje optymalnych rezultatów. 
Konieczne było balansowanie między agresywnym członem różniczkującym dla stabilizacji kąta, 
a członem całkującym dla eliminacji uchybu pozycji, co często prowadziło do niestabilności układu.

Wstępne próby doboru metodą prób i~błędów (Rys.~\ref{fig:pid_manual}), oparte 
na~dekompozycji problemu (najpierw stabilizacja wahadła, potem pozycja wózka), 
nie pozwoliły uzyskać stabilności i jakość regulacji była niezadowalająca. 
Układ charakteryzował się znacznymi oscylacjami. 
Wzmocnienia proporcjonalne ($K_p=-10$ dla kąta) były niewystarczające,
aby szybko tłumić odchylenia od~pionu.

Aby wyeliminować subiektywność strojenia ręcznego, zastosowano metodę 
przeszukiwania siatki (ang.~\textit{grid search}). Metoda ta polega na~systematycznym 
przeglądaniu zdefiniowanej przestrzeni parametrów, ewaluując błąd $MSE$ dla każdej 
kombinacji wartości z~zadanego zbioru dyskretnego. Przeszukano siatkę 
wartości dla każdego z~sześciu parametrów ($K_p$, $K_i$, $K_d$ dla obu pętli), 
wybierając konfigurację minimalizującą błąd średniokwadratowy.
\begin{figure}[H]
    \centering
    \includegraphics[width=1.0\textwidth]{images/tuning/pdpd_1_manual.png}
    \caption{Przebiegi sygnałów dla regulatora PID przy nieoptymalnych nastawach ($K_{p,\theta}=-10$, $K_{i,\theta}=-1$,$K_{d,\theta}=-3$, 
    $K_{p,x}=-1$, $K_{i,x}=-0,1$, $K_{d,x}=-3$).}
    \label{fig:pid_manual}
\end{figure}


\begin{figure}[H]
    \centering
    \includegraphics[width=1.0\textwidth]{images/tuning/pdpd_3_opt.png}
    \caption{Regulator PID z nastawami z przeszukiwania siatki ($K_{p,\theta}=-95$, $K_{i,\theta}=0$, $K_{d,\theta}=-14$, 
    $K_{p,x}=-16$, $K_{i,x}=0$, $K_{d,x}=-14$).}
    \label{fig:pdpd_opt}
\end{figure}

Nastawy dobrane przy pomocy metody siatki (Rys.~\ref{fig:pdpd_opt}) charakteryzują się znacznie wyższymi
wzmocnieniami niż dobrane ręcznie: $K_{p,\theta}=-95$ (vs. $-10$) oraz $K_{p,x}=-16$ 
(vs. $-1$). W~wyniku optymalizacji ustalono, że intensywna reakcja na~błąd pozycji wózka pośrednio
stabilizuje wahadło, ponieważ wymusza szybkie korekty trajektorii. Jednak w tym przypadku jakość 
sygnału sterującego była niezadowalająca i ostateczne strojenie znów wykonano ręcznie, tym razem biorąc 
już pod uwagę wyniki uzyskane podczas przeszukiwania siatki.

\begin{figure}[H]
    \centering
    \includegraphics[width=1.0\textwidth]{images/tuning/pdpd_2_integral_bad.png}
    \caption{Regulator PID nastawiony ręcznie ($K_{p,\theta}=-40$, $K_{i,\theta}=-1$, $K_{d,\theta}=-8$, 
    $K_{p,x}=-1$, $K_{p,x}=-0,1$, $K_{d,x}=-3$).}
    \label{fig:pid_final}
\end{figure}
Ostateczny regulator PID charakteryzuje się szybkim dochodzeniem do wartości zadanej, małymi błędami $MSE$ i $MAE$
oraz wysoką jakością sygnału sterującego. Udało się uzyskać kompromis, w którym sterowanie jest dynamiczne, 
ale nie powoduje nasycenia siłownika ani niebezpiecznych oscylacji. Czas regulacji oraz przeregulowania 
zostały zminimalizowane, co czyni ten regulator solidnym punktem odniesienia dla bardziej 
zaawansowanych strategii sterowania. 

W~implementacji programowej przyjęto następujące
nastawy:
\begin{itemize}
    \item Tor stabilizacji kąta: $K_{p,\theta} = -40,0$, $K_{i,\theta} = -1,0$, $K_{d,\theta} = -8,0$.
    Ujemne znaki wynikają z~przyjętej konwencji układu współrzędnych i~zwrotu siły.
    \item Tor pozycji: $K_{p,x} = -1,0$, $K_{i,x} = -0,1$, $K_{d,x} = -3,0$.
\end{itemize}
\subsection{Układ hybrydowy PID-LQR}

Regulator liniowo-kwadratowy (LQR) stanowi fundamentalną metodę sterowania optymalnego
dla systemów liniowych wielowymiarowych MIMO~\cite{Jezierski2017}. 
W~odróżnieniu od~regulatorów PID, które wymagają empirycznego doboru wzmocnień 
dla każdej zmiennej stanu, LQR wyznacza optymalne wzmocnienia automatycznie 
na~podstawie modelu liniowego obiektu oraz macierzy wag $Q$ i~$R$ definiujących 
kompromis między jakością regulacji a~zużyciem energii.
Problem LQR polega na~znalezieniu prawa sterowania $u(t) = -K x(t)$, które 
minimalizuje wskaźnik jakości:
\begin{equation}
    J = \int_{0}^{\infty} \left( x(t)^T Q x(t) + u(t)^T R u(t) \right) dt,
\end{equation}
gdzie $Q \succeq 0$ jest macierzą wag stanu, a~$R > 0$ wagą sterowania. 
Optymalna macierz wzmocnień $K$ wyznaczana jest poprzez rozwiązanie algebraicznego 
równania Riccatiego:
\begin{equation}
    A^T P + P A - P B R^{-1} B^T P + Q = 0,
\end{equation}
skąd $K = R^{-1} B^T P$. Macierze $A$ i~$B$ pochodzą z~linearyzacji modelu wahadła 
wokół górnego punktu równowagi ($\theta = 0$).
Klasa \texttt{PIDLQRController} implementuje sterowanie
oparte na~pełnym wektorze stanu, wspomagane dodatkowym członem PID dla uchybu
pozycji, co tworzy strukturę hybrydową opisaną m.in. w~\cite{Prasad2014} oraz
\cite{Nguyen2024} (w~kontekście porównawczym). Schemat blokowy tego układu 
przedstawiono na~Rys.~\ref{fig:diagram_pdlqr}.

\begin{figure}[H]
    \centering
    \begin{tikzpicture}[auto, node distance=1.4cm, >=Stealth]
        % Wejście
        \node [input] (in) {};
        
        % Suma błędu LQR
        \node [sum, right=0.8cm of in] (sum_lqr) {\tiny $+$};
        
        % Blok LQR
        \node [block, right=0.8cm of sum_lqr] (lqr) {LQR};
        
        % Suma sterowania
        \node [sum, right=1.2cm of lqr] (sum_u) {\tiny $+$};
        
        % Saturacja i obiekt
        \node [bigblock, right=1.5cm of sum_u] (plant) {Wahadło};
        
        % Wyjście
        \node [output, right=1.2cm of plant] (out) {};
        
        % PD pozycji (poniżej)
        \node [sum, below=1.4cm of sum_lqr] (sum_pd) {\tiny $+$};
        \node [block, right=0.8cm of sum_pd] (pd_pos) {$\mathrm{PID}_x$};
        
        % --- Połączenia ---
        % Wejście LQR
        \draw [arrow] (in) -- node[above, font=\scriptsize] {$x_{\mathrm{ref}}$} (sum_lqr);
        \draw [arrow] (sum_lqr) -- (lqr);
        \draw [arrow] (lqr) -- node[above, font=\scriptsize] {$u_{\mathrm{LQR}}$} (sum_u);
        
        % PD -> suma sterowania
        \draw [arrow] (pd_pos.east) -| node[above left, font=\scriptsize] {$u_{\mathrm{PID}}$} (sum_u.south);
        
        % Reszta toru

        \draw [arrow] (sum_u) -- node[above, font=\scriptsize] {$u$} (plant);
        \draw [arrow] (plant) -- node[above, font=\scriptsize] {$x$} (out);
        
        % Wejście referencyjne PD
        \node [input, left=0.8cm of sum_pd] (in_pd) {};
        \draw [arrow] (in_pd) -- node[above, font=\scriptsize] {$x_{\mathrm{ref}}$} (sum_pd);
        \draw [arrow] (sum_pd) -- (pd_pos);
        
        % Sprzężenie zwrotne LQR (na dole) - ciągła strzałka
        \draw [arrow] ($(plant.east) + (0.3,0)$) -- ++(0,1.4) -| (sum_lqr.north);
        \node [above=3pt of sum_lqr.north, font=\tiny] {$-$};
        
        % Sprzężenie zwrotne PD (x) - od głównej linii sprzężenia
        \draw [arrow] ($(plant.east) + (0.3,0)$) -- ++(0,-3.4) -| (sum_pd.south);
        \node [below=3pt of sum_pd.south, font=\tiny] {$-$};
        
        % Ramka LQR
        \begin{scope}[on background layer]
            \node [draw, dashed, rounded corners, fill=green!5, 
                   fit=(sum_lqr) (lqr), inner sep=6pt] {};
        \end{scope}
    \end{tikzpicture}
    \caption{Schemat blokowy hybrydowego regulatora PID-LQR.}
    \label{fig:diagram_pdlqr}
\end{figure}

Problem LQR polega na~znalezieniu prawa sterowania
$u(t) = -K x(t)$, które minimalizuje wskaźnik jakości:
\begin{equation}
    J = \int_{0}^{\infty} \left( x(t)^T Q x(t) + u(t)^T R u(t) \right) dt,
\end{equation}
gdzie $Q \succeq 0$ jest macierzą wag stanu, a~$R > 0$ wagą
sterowania. Optymalna macierz wzmocnień $K$ wyznaczana jest poprzez
rozwiązanie algebraicznego równania Riccatiego:
\begin{equation}
    A^T P + P A - P B R^{-1} B^T P + Q = 0,
\end{equation}
skąd $K = R^{-1} B^T P$. Macierze $A$
i~$B$ pochodzą z~linearyzacji modelu wahadła wokół punktu równowagi
górnej ($\theta = 0$).

W~zaimplementowanym rozwiązaniu, sygnał sterujący
składa się z~dwóch komponentów:
\begin{equation}
    u(t) = u_{\mathrm{LQR}}(t) + u_{\mathrm{PID,pos}}(t).
\end{equation}
Składnik LQR realizuje stabilizację wokół punktu pracy:
\begin{equation}
    u_{\mathrm{LQR}}(t) = -K \cdot (x(t) - x_{\mathrm{ref}}).
\end{equation}
Dodatkowy człon PID na~pętli pozycji (zrealizowany analogicznie do Rów.~\ref{eq:pd_x}) 
ma na~celu poprawę śledzenia skokowych zmian wartości zadanej
$x_{\mathrm{ref}}$, co jest częstą praktyką w~aplikacjach praktycznych, gdzie LQR
zapewnia stabilność, a~regulator zewnętrzny dba o~uchyb w~stanie ustalonym
\cite{Varghese2017}.

\subsubsection{Dobór wag macierzy Q i R}
Dobór wartości elementów macierzy wag $Q$ i~$R$ zrealizowano w~sposób
wieloetapowy, ewoluując od~konfiguracji bazowej do~rozwiązania
zoptymalizowanego. W~pierwszej kolejności zbadano zachowanie układu dla nastaw
jednostkowych, co pozwoliło zidentyfikować podstawowe ograniczenia stabilności.
Następnie, wykorzystując wiedzę o~dynamice obiektu, przeprowadzono strojenie
ręczne, by~w~końcowym etapie wykorzystać algorytmy numeryczne do~finalnego
dostrojenia parametrów i~maksymalizacji wskaźnika jakości regulacji.

W~pierwszej fazie przyjęcie jednostkowej macierzy diagonalnej $Q=I$ oraz $R=1$
(Rys.~\ref{fig:lqr_bad}) okazało się niewystarczające. Mimo teoretycznej stabilności 
wynikającej z~rozwiązania równania, wahadło wykonywało bardzo duże wychylenia, 
a~wózek wielokrotnie wyjeżdżał poza dopuszczalny zakres roboczy toru. Problem wynikał
z~faktu, że jednostkowe wagi traktują 1~rad błędu kąta tak samo jak 1~m błędu pozycji
i~1~N$^2$ kosztu sterowania -- co jest fizycznie nieuzasadnione.

\begin{figure}[H]
    \centering
    \includegraphics[width=1.0\textwidth]{images/tuning/pdlqr_1_bad.png}
    \caption{Regulator LQR z~wagami jednostkowymi ($Q=I$, $R=1$, 
    PID: $K_{p,x}=-4,5$, $K_{i,x}=0$, $K_{d,x}=-3$).}
    \label{fig:lqr_bad}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=1.0\textwidth]{images/tuning/pdlqr_2_manual.png}
    \caption{Regulator LQR strojony metodą Brysona ($Q=\mathrm{diag}([25, 1, 4, 1])$, 
    $R=10$, PID: $K_{p,x}=-4.5$, $K_{p,x}=0$, $K_{d,x}=-3$).}
    \label{fig:lqr_manual}
\end{figure}

Następnie przeprowadzono strojenie ręczne metodą prób i~błędów, inspirując się
regułą Brysona (Rys.~\ref{fig:lqr_manual}). Reguła ta postuluje, że elementy 
diagonalne macierzy $Q$ i~$R$ powinny być odwrotnie proporcjonalne do~kwadratów 
maksymalnych dopuszczalnych wartości odpowiednich zmiennych stanu i~sterowania, 
tj. $Q_{ii} = 1/x_{i,\max}^2$ oraz $R = 1/u_{\max}^2$. Ręczne zwiększanie kar 
za~wychylenie kąta ($Q_{\theta}=25$) poprawiło sztywność wahadła. Udało się ustalić 
zestaw wag zapewniający stabilną pracę, choć czas regulacji był wciąż niezadowalający, 
a~reakcja na~zakłócenia powolna.

\begin{figure}[H]
    \centering
    \includegraphics[width=1.0\textwidth]{images/tuning/pdlqr_3_opt.png}
    \caption{Zoptymalizowany regulator PID-LQR bez członu całkującego 
    ($Q=\mathrm{diag}([200, 3, 35, 40])$, $R=1$, PID: $K_{p,x}=-7{,}0$, 
    $K_{i,x}=0{,}1$, $K_{d,x}=-3{,}0$).}
    \label{fig:lqr_opt}
\end{figure}

W~ostatnim etapie zastosowano optymalizację numeryczną (Rys.~\ref{fig:lqr_opt}). 
Metoda przeszukiwania siatki poszukiwała optymalnych elementów diagonalnych macierzy $Q$ 
oraz skalara $R$, minimalizując wskaźnik jakości. Zoptymalizowane wagi 
sprawiają, że regulator bardzo 
intensywnie koryguje wychylenia wahadła, co wymusza stabilne utrzymanie kąta wychylenia. 
Należy zauważyć, że optymalizator wyznaczył strategię dość intuicyjną: 
kara głównie kąt ($Q_{\theta}$), zamiast kłaść nacisk na~pozycję ($Q_x$), 
co zmusza obiekt do~szybkich korekt stabilizujących wahadło.
Zastosowane wagi optymalne to:
\begin{equation}
    Q = \text{diag}([200,\; 3,\; 35,\; 40]), \quad R = 1.
\end{equation}
\subsection{Nieliniowe sterowanie predykcyjne (MPC)}

Algorytm MPC (Model Predictive Control) stanowi zaawansowaną metodę sterowania,
która w~odróżnieniu od~LQR, uwzględnia wprost ograniczenia sygnału sterującego
oraz nieliniową dynamikę obiektu \cite{Camacho2007}.
Zaimplementowany w~klasie \texttt{MPCController} 
algorytm rozwiązuje w~każdym kroku symulacji problem optymalizacji dynamicznej
nieliniowej (NMPC). Zasadę działania regulatora MPC ilustruje Rys.~\ref{fig:diagram_mpc}.

\begin{figure}[H]
    \centering
    \begin{tikzpicture}[auto, node distance=1.4cm, >=Stealth]
        % Wejście
        \node [input] (in) {};
        
        % Optymalizator MPC
        \node [draw, fill=orange!15, rectangle, minimum height=3em, minimum width=5em, 
               right=1cm of in, rounded corners=3pt, align=center, font=\small] (opt) {
            Optymalizator\\[-2pt]
            \scriptsize $\min J(\Delta U)$
        };
        
        % Obiekt
        \node [bigblock, right=1.5cm of opt] (plant) {Wahadło};
        
        % Wyjście
        \node [output, right=1.2cm of plant] (out) {};
        
        % Model predykcyjny (poniżej optymalizatora)
        \node [draw, fill=yellow!20, rectangle, minimum height=2em, minimum width=4em,
               below=1cm of opt, rounded corners=2pt, font=\small] (model) {Model $f(x,u)$};
        
        % --- Połączenia ---
        % Wejście -> Optymalizator
        \draw [arrow] (in) -- node[above, font=\scriptsize] {$x_{\mathrm{ref}}$} (opt);
        
        % Optymalizator -> Obiekt
        \draw [arrow] (opt) -- node[above, font=\scriptsize] {$u^*_0$} (plant);
        
        % Obiekt -> Wyjście
        \draw [arrow] (plant) -- node[above, font=\scriptsize] {$x$} (out);
        
        % Sprzężenie zwrotne - ciągła strzałka
        \draw [arrow] ($(plant.east) + (0.3,0)$) -- ++(0,-0.8) -| node[pos=0.25, below, font=\scriptsize] {$x(t)$} ($(opt.south) + (0.6,0)$);
        
        % Predykcja: Optymalizator <-> Model (dwukierunkowe, obok siebie)
        \draw [arrow, dashed] ($(opt.south) + (-0.3,0)$) -- ($(model.north) + (-0.3,0)$);
        \draw [arrow, dashed] ($(model.north) + (0.3,0)$) -- node[right, font=\scriptsize] {$\hat{x}$} ($(opt.south) + (0.3,0)$);
        
        % Ramka MPC
        \begin{scope}[on background layer]
            \node [draw, dashed, rounded corners, fill=blue!5, 
                   fit=(opt) (model), inner sep=8pt, 
                   label={[font=\scriptsize]below:Regulator MPC}] {};
        \end{scope}
    \end{tikzpicture}
    \caption{Schemat blokowy regulatora MPC z~wewnętrznym modelem predykcyjnym.}
    \label{fig:diagram_mpc}
\end{figure}
W każdym kroku algorytmu regulacji predykcyjnej zostaje wyznaczona przyszła sekwencja sygnału sterującego, przedstawiona jako wektor przyrostów sygnału sterującego:
\begin{equation}
\Delta u(k) = \left[ \Delta u(k|k) \quad \Delta u(k+1|k) \quad \dots \quad \Delta u(k+N_{u}-1|k) \right]^{T}
\end{equation}
\begin{equation} \tag{15}
\Delta u_{p}(k)=\Delta u(k+p|k)
\end{equation}
klasyczna funkcja kosztu dla MPC prezentuje się w następujący sposób:
\begin{equation}
e_{p}(k)={x}_{\mathrm{ref}}(k+p|k) - \hat{x}(k+p|k)
\end{equation}
\begin{equation} 
J(k)=\sum_{p=1}^{N}e_{p}(k)^{T}Q~e_{p}(k)+\sum_{p=0}^{N_{u}-1}\Delta u_{p}(k)^{T}R\Delta u_{p}(k)
\end{equation}
przy ograniczeniach:
\begin{align}
    \hat{x}_{k+1} &= f(\hat{x}_k, u_k), \quad k=0,\dots,N-1 \\
    u_{\mathrm{min}} &\le u_k \le u_{\mathrm{max}}, \\
\end{align}
gdzie:
\begin{itemize}
    \item $N $ -- horyzont predykcji,
    \item $N_u$ -- horyzont sterowania. 
    \item $f(\cdot)$ -- nieliniowy model dyskretny obiektu (całkowanie metodą
    Rungego-Kutty 4. rzędu),
    \item $Q $ -- macierz kar stanu,
    \item $R$-- współczynnik kary za~zmianę sterowania ($\Delta u$).
\end{itemize}
Kluczową zaletę MPC, podkreślaną w~pracach \cite{Mills2009} oraz
\cite{Jezierski2017}, jest możliwość bezpośredniego uwzględnienia ograniczeń
(saturacji) już na~etapie wyliczania sterowania, co zapobiega zjawisku
nasycenia elementu wykonawczego, które mogłoby mieć miejsce w~przypadku LQR.

Zadanie optymalizacji rozwiązywane jest numerycznie metodą SQP (Sequential
Quadratic Programming) przy użyciu solwera \texttt{SLSQP} z~biblioteki 
\texttt{scipy.optimize}. Wybór tego solwera podyktowany był jego dostępnością 
w~popularnych dystrybucjach środowisk naukowych (Anaconda, pip) oraz zdolnością 
do~obsługi ograniczeń nierównościowych.


\subsubsection{Dobór horyzontu i wag funkcji celu}
Dla regulatora MPC kluczowym zagadnieniem był dobór horyzontu predykcji oraz
macierzy wag, determinujących zachowanie układu w~stanie nieustalonym.

\begin{figure}[H]
    \centering
    \includegraphics[width=1.0\textwidth]{images/tuning/mpc_1_bad.png}
    \caption{Regulator MPC z~krótkim horyzontem ($N=5$, $N_u=2$, 
    $Q=\mathrm{diag}([10, 1, 10, 1])$, $R=0.1$).}
    \label{fig:mpc_bad}
\end{figure}

Początkowe ustawienie zbyt krótkiego horyzontu predykcji ($N = 5$,
Rys.~\ref{fig:mpc_bad}) prowadziło do~niestabilności układu zamkniętego. Horyzont 
predykcji był zbyt krótki, aby regulator mógł uwzględnić, że rozpędzając wózek 
w~celu korekcji kąta, nie zdąży wyhamować przed upadkiem wahadła lub osiągnięciem końca toru. Horyzont pięciu 
kroków jest niewystarczający, aby uchwycić pełną
dynamikę wahadła i~zaplanować odpowiedni manewr powrotny.

\begin{figure}[H]
    \centering
    \includegraphics[width=1.0\textwidth]{images/tuning/mpc_2_manual.png}
    \caption{Regulator MPC z~ręcznie dobranymi wagami ($N=10$, $N_u=3$, 
    $Q=\mathrm{diag}([50, 10, 50, 10])$, $R=0.1$).}
    \label{fig:mpc_manual}
\end{figure}

Zwiększenie horyzontu do~$N=10$ w~ramach korekty ręcznej 
(Rys.~\ref{fig:mpc_manual}) ustabilizowało proces. Dłuższy horyzont umożliwił 
predykcję na~$1{,}0$~s, co pozwoliło na~antycypację skutków podejmowanych działań 
sterujących. Dodatkowa manipulacja wagami $Q$ pozwoliła na~uzyskanie poprawnego 
sterowania, jednak odpowiedź dynamiczna była powolna, a~przebiegi wykazywały
przeregulowania.

\begin{figure}[H]
    \centering
    \includegraphics[width=1.0\textwidth]{images/tuning/mpc_3_opt.png}
    \caption{Zoptymalizowany regulator MPC ($N=12$, $N_u=4$, 
    $Q=\mathrm{diag}([158, 41, 43, 20])$, $R=0,086$).}
    \label{fig:mpc_opt}
\end{figure}

Automatyzacja procesu strojenia przy użyciu skryptu \texttt{tune\_mpc.py} pozwoliła
na~znalezienie kompromisu między długością horyzontu a~wagami (Rys.~\ref{fig:mpc_opt}).
Algorytm optymalizacyjny wskazał $N=12$ (co odpowiada $1{,}2$~s predykcji) 
jako optimum dla tego modelu dyskretnego, zapewniając stabilność przy akceptowalnym czasie obliczeń. 

Ostateczne nastawy regulatora MPC to:
$Q=\mathrm{diag}([158, 41, 43, 20])$, $R=0,086$.

\subsection{MPC z~rozszerzonym wskaźnikiem jakości (MPC-alt)}

Dodatkowo zaimplementowano regulator MPC z alternatywną funkcją kosztu. 
Jego struktura jest zbliżona do~podstawowego MPC, jednak funkcja kosztu została rozbudowana
o~dodatkowy składnik karzący bezwzględną wartość sygnału sterującego (energię).

Zmodyfikowana funkcja celu:
\begin{equation}
e_{p}(k)={x}_{\mathrm{ref}}(k+p|k) - \hat{x}(k+p|k)
\end{equation}
\begin{equation} 
J(k)=\sum_{p=1}^{N}e_{p}(k)^{T}Q~e_{p}(k)+\sum_{p=0}^{N_{u}-1}\Delta u_{p}(k)^{T}R\Delta u_{p}(k) + \sum_{p=0}^{N_{u}-1} u_{p}(k)^{T}R_{abs} u_{p}(k)
\end{equation}

Wprowadzenie parametru $R_{\mathrm{abs}}$ pozwala na~bezpośrednie minimalizowanie
zużycia energii sterowania, co jest podejściem powszechnie stosowanym
w~praktycznych implementacjach algorytmów predykcyjnych \cite{Camacho2007}.
Ograniczenie amplitudy sygnału sterującego nie tylko redukuje wydatek energetyczny
(istotny w~aplikacjach mobilnych), ale także zmniejsza obciążenie mechaniczne
elementów wykonawczych, co wpływa na~żywotność napędu.

\subsubsection{Dobór parametrów i analiza wpływu kary za energię}
W~przypadku wariantu MPC-alt analizowano nieliniowy wpływ parametru $R_{\mathrm{abs}}$
na~zachowanie układu. Eksperymenty przeprowadzono przy stałych wagach stanu takich samych jak dla MPC:
\begin{equation} 
Q=\mathrm{diag}([158, 41, 43, 20])
\end{equation}
oraz przy bardzo niskiej karze za~przyrosty
sterowania $R_{\Delta} = 0{,}001$, zmieniając jedynie wartość kary za~bezwzględną 
wartość sterowania.

Wprowadzenie członu $\sum_{p=0}^{N_{u}-1} u_{p}(k)^{T}R_{abs} u_{p}(k)$ do~funkcji celu ma 
fundamentalnie inny charakter niż kara za~przyrosty sterowania $R_{\Delta}$. 
Podczas gdy $R_{\Delta}$ promuje gładkość sygnału sterującego (ogranicza szybkie
zmiany), parametr $R_{\mathrm{abs}}$ bezpośrednio kara za amplitudę siły, 
co przekłada się na~redukcję zużycia energii.

\begin{figure}[H]
    \centering
    \includegraphics[width=1.0\textwidth]{images/tuning/mpcJ2_1_bad.png}
    \caption{Regulator MPC-alt z~wysoką karą za~energię ($R_{\mathrm{abs}}=10$).}
    \label{fig:mpcj2_bad}
\end{figure}

Przyjęcie zbyt dużej wartości kary za~sterowanie bezwzględne ($R_{\mathrm{abs}}=10$,
Rys.~\ref{fig:mpcj2_bad}) spowodowało, że regulator wykazywał tendencję do~pasywności.
Funkcja kosztu karała każdy niuton siły na~tyle intensywnie, że wartość funkcji celu
faworyzowała bardzo wolną regulację kosztem uniknięcia wysokiego wydatku energetycznego. W~efekcie układ
nie był w~stanie ustabilizować się -- wahadło oscylowało w okolicy punktu pracy, ponieważ koszt 
energetyczny utrzymania go w~pionie przewyższał zysk wynikający z~małego błędu 
kątowego w~funkcji celu.

\begin{figure}[H]
    \centering
    \includegraphics[width=1.0\textwidth]{images/tuning/mpcJ2_2_manual.png}
    \caption{Regulator MPC-alt z~ręcznie zmniejszoną karą ($R_{\mathrm{abs}}=5$).}
    \label{fig:mpcj2_manual}
\end{figure}

Stopniowe, ręczne zmniejszanie parametru $R_{\mathrm{abs}}$ do~wartości $5$
(Rys.~\ref{fig:mpcj2_manual}) pozwoliło delikatnie polepszyć jakość regulacji, jednak układ
ostatecznie nie dawał rady się ustabilizować. Regulator działał zbyt zachowawczo -- oszczędzając
energię, pozwalał wózkowi na~zbyt duży dryf od~pozycji zadanej i za bardzo oszczędzał energię. 
Taki scenariusz ilustruje typowy problem źle dostrojonego kompromisu
między jakością regulacji a~oszczędnością energii.

\begin{figure}[H]
    \centering
    \includegraphics[width=1.0\textwidth]{images/tuning/mpcJ2_3_opt.png}
    \caption{Zoptymalizowany regulator MPC-alt ($R_{\mathrm{abs}}=1$).}
    \label{fig:mpcj2_opt}
\end{figure}

Kolejne próby zmniejszania kary za bezwzględną wartość wskazały, że dla tego zadania najlepszym rozwiązaniem jest
zastosowanie niewielkiej, ale niezerowej kary za~bezwzględną wartość sterowania ($R_{\mathrm{abs}}=1$,
Rys.~\ref{fig:mpcj2_opt}). Tak dobrana waga pozwala uniknąć bierności regulatora,
jednocześnie ograniczając nadmierne zużycie energii. W~połączeniu z~karą za~przyrosty sterowania 
$R_{\Delta}=0.001$, zapewniono gładkość sygnału sterującego bez ograniczania
zdolności regulatora do~szybkiej reakcji. Uzyskano optymalny kompromis, w~którym układ
stabilizuje się szybko, a~sterowanie pozbawione jest zbędnych oscylacji.

\subsection{Liniowy regulator MPC (LMPC)}

Zaimplementowano również wariant Liniowego MPC (LMPC), którego implementacja 
została oparta na~strukturze regulatora NMPC, z~zastąpieniem modelu nieliniowego 
modelem zlinearyzowanym. Główna idea polega na~wykorzystaniu zlinearyzowanego modelu 
obiektu wokół punktu równowagi górnej ($\theta = 0$) w~celu uproszczenia 
obliczeń optymalizacyjnych.

Linearyzacja modelu wahadła odwróconego prowadzi do~układu w~postaci 
przestrzeni stanów:
\begin{equation}
    \dot{x} = A_c x + B_c u,
\end{equation}
gdzie macierze $A_c$ i~$B_c$ wyznaczono analitycznie (metodą Jacobiego) dla~punktu 
równowagi $\theta = 0$, $\dot{\theta} = 0$. Model ciągły poddano następnie 
dyskretyzacji metodą ekstrapolatora zerowego rzędu (ZOH -- Zero-Order Hold), 
uzyskując równanie stanu w~postaci dyskretnej:
\begin{equation}
    x_{k+1} = A_d x_k + B_d u_k.
\end{equation}
Dyskretyzacja ZOH zakłada, że~sygnał sterujący $u$ pozostaje stały w~przedziale 
$[k \cdot dt, (k+1) \cdot dt]$, co odpowiada rzeczywistemu działaniu cyfrowego 
układu sterowania. Do~wyznaczenia macierzy $A_d$ i~$B_d$ wykorzystano funkcję 
\texttt{cont2discrete} z~biblioteki \texttt{scipy.signal}.

Dzięki zastosowaniu modelu liniowego, predykcja trajektorii stanu (w~przeciwieństwie 
do~NMPC) sprowadza się do~szybkich operacji macierzowych, bez konieczności 
numerycznego całkowania równań różniczkowych metodą Rungego-Kutty. Dla~zadanej 
sekwencji sterowania $\{u_0, u_1, \ldots, u_{N-1}\}$ predykcja ma postać:
\begin{equation}
    \hat{x}_{k+1} = A_d \hat{x}_k + B_d u_k, \quad k = 0, \ldots, N-1.
\end{equation}

funkcja kosztu przyjmuje postać analogiczną do nieliniowego MPC:
\begin{equation}
e_{p}(k)={x}_{\mathrm{ref}}(k+p|k) - \hat{x}(k+p|k)
\end{equation}
\begin{equation} 
J(k)=\sum_{p=1}^{N}e_{p}(k)^{T}Q~e_{p}(k)+\sum_{p=0}^{N_{u}-1}\Delta u_{p}(k)^{T}R\Delta u_{p}(k)
\end{equation}

Do rozwiązania problemu sterowania użyto solvera \texttt{SLSQP} z~biblioteki 
\texttt{scipy.optimize}, identycznego jak w~przypadku nieliniowego MPC. 
Zastosowanie tego samego solvera dla obu wariantów MPC pozwala na~bezpośrednie 
porównanie wpływu uproszczenia modelu (liniowy vs. nieliniowy) na~jakość regulacji, 
eliminując różnice wynikające z~wyboru algorytmu optymalizacji.

\subsubsection{Dobór parametrów i~analiza działania}

Regulator LMPC dostrojono ręcznie metodą prób i błędów.
Najpierw przetestowano zestaw wag $Q=\text{diag}([1, 1, 1, 1])$, $R=0,1$.
\begin{figure}[H]
    \centering
    \includegraphics[width=1.0\textwidth]{images/tuning/lmpc_bad.png}
    \caption{Przebiegi czasowe dla liniowego regulatora MPC ($N=12$, $N_u=4$, 
    $Q=\text{diag}([1, 1, 1, 1])$, $R=0,1$).}
    \label{fig:lmpc_bad}
\end{figure}
Na~Rys.~\ref{fig:lmpc_opt} widać, że pozycja wózka nie stabilizuje się wystarczająco szybko.
Zdecydowano się w kolejnym kroku zwiększyć wagi w macierzy $Q$.
\begin{figure}[H]
    \centering
    \includegraphics[width=1.0\textwidth]{images/tuning/lmpc_opt.png}
    \caption{Przebiegi czasowe dla liniowego regulatora MPC ($N=12$, $N_u=4$, 
    $Q=\text{diag}([15, 1, 15, 1])$, $R=0,1$).}
    \label{fig:lmpc_opt}
\end{figure}

Na~Rys.~\ref{fig:lmpc_opt} przedstawiono proces stabilizacji wahadła. 
Układ zachowuje się stabilnie, płynnie dochodząc do~wartości
zadanej.
Mimo zastosowania uproszczonego modelu liniowego, regulator poprawnie radzi sobie
ze~stabilizacją w~otoczeniu punktu równowagi.
Wybrane parametry dla regulatora LMPC:
horyzont predykcji: $N=12$, horyzont sterowania: $N_u=4$,
macierz wag stanu: $Q = \text{diag}([15,0,\; 1,0,\; 15,0,\; 1,0])$, waga sterowania: $R = 0,1$.

\subsection{Regulator rozmyty wspomagany LQR (Fuzzy-LQR)}

Ostatnim zbadanym układem jest sterownik hybrydowy o~strukturze równoległej, 
łączący klasyczny, liniowy regulator LQR z~nieliniowym systemem
wnioskowania rozmytego typu Takagi-Sugeno (T-S). W~przeciwieństwie do~układów typu
,,Gain Scheduling'' modyfikujących parametry jednego regulatora, tutaj zastosowano
bezpośrednie sumowanie sygnałów sterujących z~dwóch niezależnych bloków (Rys.~\ref{fig:diagram_fuzzy}).
LQR zapewnia optymalną stabilizację w~pobliżu punktu pracy (działa w~sposób ciągły), natomiast człon rozmyty
generuje dodatkowy sygnał korekcyjny, aktywujący się silniej przy większych uchybach.

\begin{figure}[H]
    \centering
    \begin{tikzpicture}[auto, node distance=1.4cm, >=Stealth]
        % Wejście
        \node [input] (in) {};
        
        % Suma błędu
        \node [sum, right=0.8cm of in] (sum_e) {\tiny $+$};
        
        % Blok LQR (góra)
        \node [block, right=1.8cm of sum_e, yshift=0.7cm] (lqr) {LQR};
        
        % Blok Fuzzy (dół)
        \node [draw, fill=purple!15, rectangle, minimum height=2.2em, minimum width=4em,
               right=1.8cm of sum_e, yshift=-0.7cm, rounded corners=3pt, font=\small] (fuzzy) {Fuzzy T-S};
        
        % Suma sterowania
        \node [sum, right=1.5cm of lqr, yshift=-0.7cm] (sum_u) {\tiny $+$};
        
        % Saturacja i obiekt
        \node [bigblock, right=1.8cm of sum_u] (plant) {Wahadło};
        
        % Wyjście
        \node [output, right=1.2cm of plant] (out) {};
        
        % --- Połączenia ---
        % Wejście -> Suma błędu
        \draw [arrow] (in) -- node[above, font=\scriptsize] {$x_{\mathrm{ref}}$} (sum_e);
        
        % Suma błędu -> rozgałęzienie do LQR i Fuzzy
        \draw [line] (sum_e.east) -- ++(0.5,0) coordinate (branch);
        \draw [arrow] (branch) |- (lqr.west);
        \draw [arrow] (branch) |- (fuzzy.west);
        
        % LQR i Fuzzy -> Suma sterowania
        \draw [arrow] (lqr.east) -| (sum_u.north);
        \draw [arrow] (fuzzy.east) -| (sum_u.south);
        
        % Reszta toru
        \draw [arrow] (sum_u) -- node[above, font=\scriptsize] {$u$} (plant);
        \draw [arrow] (plant) -- node[above, font=\scriptsize] {$x$} (out);
        
        % Sprzężenie zwrotne - ciągła strzałka
        \draw [arrow] ($(plant.east) + (0.3,0)$) -- ++(0,-1.8) -| (sum_e.south);
        \node [below=3pt of sum_e.south, font=\tiny] {$-$};
    \end{tikzpicture}
    \caption{Schemat blokowy regulatora Fuzzy-LQR z~równoległą strukturą hybrydową.}
    \label{fig:diagram_fuzzy}
\end{figure}
Sygnał sterujący:
\begin{equation}
    u(t) = \text{sat}\left( u_{LQR}(t) + G \cdot u_{Fuzzy}(t) \right),
\end{equation}
gdzie $G$ to globalne wzmocnienie skalujące część rozmytą, a funkcja $\text{sat}(\cdot)$ reprezentuje fizyczne ograniczenie siły napędu.
Część rozmyta $u_{\mathrm{Fuzzy}}(t)$ wykorzystuje bazę reguł postaci:
\begin{quote}
    JEŚLI $e_\theta$ jest $A_i$ ORAZ $\dot{\theta}$ jest $B_i$ ... TO $u_i = f_i(x)$,
\end{quote}
gdzie $f_i(x)$ jest liniową funkcją stanu (lokalny regulator
liniowy). Zastosowano funkcje przynależności trójkątne dla zmiennych stanu,
dzieląc przestrzeń na~obszary ,,Mały błąd'' i~,,Duży błąd''.
Kształt zastosowanych funkcji przynależności przedstawiono na~Rys.~\ref{fig:fuzzy_membership}.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.95\textwidth]{images/diagrams/fuzzy_membership.png}
    \caption{Trójkątne funkcje przynależności dla czterech zmiennych stanu 
    regulatora Fuzzy-LQR. Każda zmienna posiada dwa zbiory rozmyte: 
    ,,Mały błąd'' (aktywny w~pobliżu zera) oraz ,,Duży błąd'' 
    (aktywny przy większych odchyleniach od~punktu równowagi).}
    \label{fig:fuzzy_membership}
\end{figure}

Baza wiedzy składa się z~16 reguł ($2^4$ kombinacji dla 4 zmiennych stanu).
Wyjście sterownika obliczane jest jako średnia ważona:
\begin{equation}
    u_{\mathrm{Fuzzy}} = G \cdot \frac{\sum_{i=1}^{16} w_i(x) \cdot u_i}{\sum_{i=1}^{16} w_i(x)},
\end{equation}
gdzie $w_i$ to stopień aktywacji $i$-tej reguły, a~$G = 0.36$ to globalne
wzmocnienie skalujące (po optymalizacji).

Zastosowana struktura równoległa pozwala na~uzyskanie efektu tożsamego z~nieliniowym
kształtowaniem wzmocnienia (ang. \textit{nonlinear gain shaping}), mimo że bazowy regulator LQR posiada stałe nastawy.
Mechanizm ten działa dwutorowo:
\begin{enumerate}
    \item W~pobliżu punktu równowagi (małe błędy) dominuje człon LQR. Udział sterownika rozmytego
    jest marginalny, co wynika z~definicji funkcji przynależności dla małych błędów (zerowe lub bardzo małe wzmocnienia dodatkowe).
    Gwarantuje to wysoką kulturę pracy i~brak drgań wokół zera.
    \item W~sytuacjach krytycznych (duże wychylenia) sterownik rozmyty generuje
    silny, dodatkowy sygnał sterujący (wynikający z~reguł \texttt{F\_rules} dla ,,Dużych błędów''),
    który sumuje się z~sygnałem LQR.
\end{enumerate} 
W~efekcie, całkowita sztywność układu regulacji rośnie wraz z~amplitudą błędu, co
pozwala na~skuteczne rozszerzenie obszaru stabilności (ang. \textit{basin of attraction})
w~porównaniu do~klasycznego LQR \cite{Nguyen2024}.

\subsubsection{Dobór reguł i funkcji przynależności}
Strojenie rozmytego regulatora Fuzzy-LQR jest zadaniem złożonym ze względu na~dużą
liczbę parametrów definiujących bazę reguł i~funkcje przynależności. 
W~przeciwieństwie do~klasycznego regulatora LQR, gdzie dobór sprowadza się do~ustalenia 
wag w~macierzach $Q$ i~$R$, tutaj należy podjąć szereg decyzji 
dotyczących kształtu, rozmieszczenia i~liczby funkcji przynależności dla każdej 
ze~zmiennych stanu. Ponadto, konieczne jest zdefiniowanie reguł wnioskowania, 
które determinują zachowanie układu w~poszczególnych obszarach przestrzeni stanu. 
Niewłaściwy dobór tych parametrów może prowadzić do~niestabilności, gwałtownych 
przełączeń sterowania lub braku pożądanej poprawy dynamiki względem regulatora bazowego.

\begin{figure}[H]
    \centering
    \includegraphics[width=1.0\textwidth]{images/tuning/fuzzy_1_bad.png}
    \caption{Regulator Fuzzy-LQR z~wąskimi funkcjami przynależności 
    (zakres ,,mały błąd'' dla $\theta$: $[-0.02, 0.02]$~rad).}
    \label{fig:fuzzy_bad}
\end{figure}

Błędne zdefiniowanie zbyt wąskich funkcji przynależności dla strefy ,,małego błędu''
(Rys.~\ref{fig:fuzzy_bad}) skutkowało gwałtownym przełączaniem się regulatora 
na~reguły o~wysokich wzmocnieniach (drgania przełączeniowe). Zakres $[-0.02, 0.02]$~rad 
oznacza, że już przy wychyleniu wahadła o~około $1^{\circ}$ regulator przeskakiwał 
z~trybu o~niskich wzmocnieniach (LQR) na~tryb o~wysokich wzmocnieniach (reguły rozmyte), 
a~przy powrocie do~pionu natychmiast wracał. Prowadziło to do~silnych drgań wokół punktu równowagi,
co jest zjawiskiem niepożądanym w~rzeczywistych układach napędowych ze~względu na~
zużycie mechaniczne i~hałas.

\begin{figure}[H]
    \centering
    \includegraphics[width=1.0\textwidth]{images/tuning/fuzzy_2_manual.png}
    \caption{Regulator Fuzzy-LQR z~ręcznie dobranymi parametrami 
    ($F_{\theta}=20$, $F_{\dot{\theta}}=5$, $F_x=10$, $F_{\dot{x}}=2$, 
    zakres: $[-0.2, 0.2]$~rad).}
    \label{fig:fuzzy_manual}
\end{figure}

Opierając się na~literaturze \cite{Nguyen2024}, dobrano ręcznie szerokości trójkątnych
funkcji przynależności tak, aby przejście między strefami było płynne 
(Rys.~\ref{fig:fuzzy_manual}). Rozszerzenie zakresu do~$[-0.2, 0.2]$~rad wyeliminowało
drgania przełączeniowe, jednak wzmocnienia reguł były zbyt słabe ($F_{\theta}=20$ vs. optymalne $100.0$).
Układ uzyskał stabilność asymptotyczną, jednak nie wykorzystywał w~pełni potencjału 
szybkiej reakcji na~duże zakłócenia, działając zachowawczo.

\begin{figure}[H]
    \centering
    \includegraphics[width=1.0\textwidth]{images/tuning/fuzzy_3_opt.png}
    \caption{Zoptymalizowany regulator Fuzzy-LQR ($F_{\theta}=100.0$, 
    $F_{\dot{\theta}}=5.27$, $F_x=19.82$, $F_{\dot{x}}=19.25$, $G=0.36$).}
    \label{fig:fuzzy_opt}
\end{figure}

Ostatecznie, dedykowany skrypt \texttt{tune\_fuzzy\_lqr.py} posłużył do~optymalizacji
wag pojedynczych reguł oraz parametrów kształtu funkcji przynależności 
(Rys.~\ref{fig:fuzzy_opt}). Algorytm wyznaczył znacznie wyższą wartość wzmocnienia
dla kąta ($F_{\theta}=100.0$), przy jednoczesnym zmniejszeniu globalnego wzmocnienia
($G=0.36$). Uzyskano nieliniową powierzchnię sterowania, która łączy zalety miękkiego 
sterowania LQR w~pobliżu zera z~maksymalną siłą reakcji przy dużych wychyleniach.

Strojenie regulatora Fuzzy-LQR okazało się zadaniem znacznie bardziej wymagającym 
niż w~przypadku pozostałych badanych algorytmów. Wynika to z~kilku czynników:
\begin{itemize}
    \item Wysoka wymiarowość przestrzeni parametrów --- dla 16 reguł, 
    z~których każda definiuje 4 wzmocnienia, plus parametry funkcji przynależności 
    i~wzmocnienie globalne, łączna liczba stopni swobody sięga kilkudziesięciu.
    \item Silne sprzężenia między parametrami --- zmiana jednego wzmocnienia 
    wpływa na~zachowanie całej bazy reguł poprzez mechanizm interpolacji rozmytej, 
    co utrudnia intuicyjne strojenie metodą prób i~błędów.
    \item Wrażliwość na~warunki początkowe optymalizacji --- algorytm 
    ewolucji różnicowej wielokrotnie zbiegał do~różnych minimów lokalnych, 
    dając rozwiązania o~znacząco odmiennych charakterystykach.
    \item Zależność od~scenariusza testowego --- parametry zoptymalizowane 
    dla warunków nominalnych mogą dawać gorsze wyniki przy zakłóceniach i~odwrotnie.
\end{itemize}
Z~powyższych powodów proces strojenia regulatora rozmytego wymagał wielokrotnego 
uruchamiania optymalizacji z~różnymi punktami startowymi oraz manualnej weryfikacji 
uzyskanych rozwiązań. Stanowi to istotną wadę praktyczną w~porównaniu z~regulatorami 
LQR czy MPC, gdzie przestrzeń parametrów jest znacznie mniejsza i~bardziej interpretowalna.
